<!DOCTYPE html>
<html>
    <head>
        <title>Pixel Art</title>
        <style>
            body {
                background-color: white;
            }

            #canvas {
                border: 1px solid #000000;
                background-color: #000000;
            }

            #controls {
                background-color: white;
            }

        </style>
    </head>
    <body>
        <div id = "menu">
            <label for="height">Height (between 1 and 250):</label>
            <input type="number" id="height" name="height" min="1" max="250" step = "1">
            <br>

            <label for="height">Width (between 1 and 250):</label>
            <input type="number" id="width" name="width" min="1" max="250" step = "1">
            <br>
            
            <button onclick="go()">Go!</button>
        </div>
        <div id = "main" style = "display: none;">
            <div id = "controls">
                <label for = "pencilColor">Pencil Color</label>
                <input type="color" id="pencilColor" name="pencilColor" value="#FF00FF" onchange="handlePencil()">
                <br>

                <label for = "backgroundColor">Background Color</label>
                <input type="color" id="backgroundColor" name="backgroundColor" value="#EEEEEE" onchange="handleBackground()">
                <br>
                <button onclick="fit()">Fit</button>
                <button onclick="clearCanvas()">Clear</button>
                <button onclick="reset()">Reset</button>
                <button onclick="download()">Download</button>
                
                <br>
                <input type="radio" id="Pencil" name="tool" value="Pencil" onclick="selectTool('pencil')">
                <label for="Pencil">Pencil</label>
                <br>
                <input type="radio" id="Eraser" name="tool" value="Eraser" onclick="selectTool('erase')">
                <label for="Eraser">Eraser</label>
                <br>
                <input type="radio" id="Fill" name="tool" value="Fill" onclick="selectTool('fill')">
                <label for="Fill">Fill</label>
                <br>
                <input type="radio" id="Pan" name="tool" value="Pan" onclick="selectTool('pan')">
                <label for="Pan">Pan</label>
                <br>
                
                
            </div>
            <br>
            <canvas id = "canvas" width="750" height="750"></canvas>
        </div>
       
        <script>
            //variables
            var heightNum = document.getElementById("height").value = 5;
            var widthNum = document.getElementById("width").value = 5;
            var pixelSize = 750/Math.max(heightNum, widthNum);
            var pixels = []

            function Pixel(x, y, color, empty){
                this.x = x;
                this.y = y;
                this.color = color;
                this.empty = empty
            }

            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext('2d');

            var backgroundColor = document.getElementById("backgroundColor").value;
            var pencilColor = document.getElementById("pencilColor").value;

            function handleBackground(){
                backgroundColor = document.getElementById("backgroundColor").value;
                render();
            }
            function handlePencil(){
                pencilColor = document.getElementById("pencilColor").value;
            }

            //TODO:
            //implement fill tool - recursive
            //implement warning message for reset and clear
            //implement undo redo
            var mouseDownArr = []
            var mouseUpArr = []
            function selectTool(tool){
                //remove previous event listeners
                emptyListeners(canvas, "mousedown", mouseDownArr);
                emptyListeners(canvas, "mouseup", mouseUpArr);
                mouseDownArr = []
                mouseUpArr = []
                
                //add correct event listeners
                if(tool == "pencil"){
                    canvas.addEventListener("mousedown", handleDrawStart);
                    canvas.addEventListener("mouseup", handleDrawEnd);
                    mouseDownArr.push(handleDrawStart);
                    mouseUpArr.push(handleDrawEnd);

                } else if (tool == "erase"){
                    canvas.addEventListener("mousedown", handleEraseStart);
                    canvas.addEventListener("mouseup", handleEraseEnd);
                    mouseDownArr.push(handleEraseStart);
                    mouseUpArr.push(handleEraseEnd);

                } else if (tool == "fill"){
                    canvas.addEventListener("mousedown", handleFillStart);
                    canvas.addEventListener("mouseup", handleFillEnd);
                    mouseDownArr.push(handleFillStart);
                    mouseUpArr.push(handleFillEnd);

                } else if (tool == "pan"){
                    canvas.addEventListener("mousedown", handlePanStart)
                    canvas.addEventListener("mouseup", handlePanEnd)
                    mouseDownArr.push(handlePanStart);
                    mouseUpArr.push(handlePanEnd);

                }
            }

            function emptyListeners(object, type, arr){
                for(var i = 0; i < arr.length; i++){
                    object.removeEventListener(type, arr[i]);
                }
            }

            const viewportTransform = {
                x: 0,
                y: 0,
                scale: 1
            }

            canvas.addEventListener("mousemove", (e) => {
                currentX = e.clientX;
                currentY = e.clientY;
            })

            let previousX = 0;
            let previousY = 0;
            let currentX = 0;
            let currentY = 0;
            //transformation updates
            function updatePanning(e){
                const localX = e.clientX;
                const localY = e.clientY;

                //console.log(previousX, previousY, localX, localY)
                viewportTransform.x += localX - previousX;
                viewportTransform.y += localY - previousY;
                
                previousX = localX;
                previousY = localY;
            }
            function updateZooming(e){
                
                const oldScale = viewportTransform.scale;
                const oldX = viewportTransform.x;
                const oldY = viewportTransform.y;

                const localX = e.clientX;
                const localY = e.clientY;

                const previousScale = viewportTransform.scale;

                var deltaY = e.deltaY;
                if(e.deltaY >= 100){
                    deltaY = 99
                }
                const newScale = viewportTransform.scale += deltaY * -0.01;

                const newX = localX - (localX - oldX) * (newScale/previousScale);
                const newY = localY - (localY - oldY) * (newScale/previousScale);

                viewportTransform.x = newX;
                viewportTransform.y = newY;
                viewportTransform.scale = newScale;
            }

            //event listeners for Zoom and Pan
            function onMouseMove(e){
                updatePanning(e);
                render();
                console.log(e);
            }
            
            document.addEventListener("keydown", (e) => {
                if(e.code == 'Space'){
                    previousX = currentX;
                    previousY = currentY
                    canvas.addEventListener("mousemove", onMouseMove);
                }
            })
            document.addEventListener("keyup", (e) => {
                if(e.code == 'Space'){
                    canvas.removeEventListener("mousemove", onMouseMove);
                }
            })

            function onMouseWheel(e){
                e.preventDefault()
                updateZooming(e)
                render()
                console.log(e)
            }
            canvas.addEventListener("wheel", onMouseWheel, {passive: false});
            
            //event handlers for draw, erase, pan
            function handleDrawStart(e){
                draw(e);
                canvas.addEventListener("mousemove", draw);
            }
            function handleDrawEnd(e){
                canvas.removeEventListener("mousemove", draw);
            }
            function handleEraseStart(e){
                erase(e);
                canvas.addEventListener("mousemove", erase);
            }
            function handleEraseEnd(e){
                canvas.removeEventListener("mousemove", erase);
            }
            function handleFillStart(e){
                fill(e);
                canvas.addEventListener("mousemove", fill);
            }
            function handleFillEnd(e){
                canvas.removeEventListener("mousemove", fill);
            }
            function handlePanStart(e){
                previousX = e.clientX;
                previousY = e.clientY;
                canvas.addEventListener("mousemove", onMouseMove);
            }
            function handlePanEnd(e){
                canvas.removeEventListener("mousemove", onMouseMove);
            }

            //rendering pixels
            function drawPixel(pixel) {
                if(pixel.empty){
                    ctx.fillStyle = backgroundColor
                } else {
                    ctx.fillStyle = pixel.color
                }
                ctx.clearRect(pixel.x, pixel.y, pixelSize*0.95, pixelSize*0.95)
                ctx.fillRect(pixel.x, pixel.y, pixelSize*0.95, pixelSize*0.95)
            }

            function draw(e) {
                for(var i = 0; i < widthNum; i++){
                    if(e.offsetX >= (pixels[i][0].x)*viewportTransform.scale + viewportTransform.x && 
                    e.offsetX <= (pixels[i][0].x)*viewportTransform.scale + viewportTransform.x + 
                    pixelSize*0.95*viewportTransform.scale){
                        for(var j = 0; j < heightNum; j++){
                            if(e.offsetY >= (pixels[i][j].y)*viewportTransform.scale + viewportTransform.y && 
                            e.offsetY <= (pixels[i][j].y)*viewportTransform.scale + viewportTransform.y + 
                            pixelSize*0.95*viewportTransform.scale){
                                pixels[i][j].color = pencilColor;
                                pixels[i][j].empty = false;
                                drawPixel(pixels[i][j]);
                                console.log(pixels[i][j]);
                            }
                        }

                        break;
                    }
                }
                
            }
                
            function erase(e){
                for(var i = 0; i < widthNum; i++){
                    if(e.offsetX >= (pixels[i][0].x)*viewportTransform.scale + viewportTransform.x && 
                    e.offsetX <= (pixels[i][0].x)*viewportTransform.scale + viewportTransform.x + 
                    pixelSize*0.95*viewportTransform.scale){
                        for(var j = 0; j < heightNum; j++){
                            if(e.offsetY >= (pixels[i][j].y)*viewportTransform.scale + viewportTransform.y && 
                            e.offsetY <= (pixels[i][j].y)*viewportTransform.scale + viewportTransform.y + 
                            pixelSize*0.95*viewportTransform.scale){
                                pixels[i][j].color = backgroundColor;
                                pixels[i][j].empty = true;
                                drawPixel(pixels[i][j]);
                                console.log(pixels[i][j]);
                            }
                        }

                        break;
                    }
                }
            }
           
            function fill(e){
                var x = -1;
                var y = -1;

                //find pixel clicked
                for(var i = 0; i < widthNum; i++){
                    if(e.offsetX >= (pixels[i][0].x)*viewportTransform.scale + viewportTransform.x && 
                    e.offsetX <= (pixels[i][0].x)*viewportTransform.scale + viewportTransform.x + 
                    pixelSize*0.95*viewportTransform.scale){
                        for(var j = 0; j < heightNum; j++){
                            if(e.offsetY >= (pixels[i][j].y)*viewportTransform.scale + viewportTransform.y && 
                            e.offsetY <= (pixels[i][j].y)*viewportTransform.scale + viewportTransform.y + 
                            pixelSize*0.95*viewportTransform.scale){
                                x = i;
                                y = j;
                            }
                        }
                        break;
                    }
                }

                fillHelper(x, y)

            }
            function fillHelper(x, y){
                
                //fill selected pixels
                const tempColor = pixels[x][y].color;

                pixels[x][y].color = pencilColor;
                pixels[x][y].empty = false;
                drawPixel(pixels[x][y])

                //check left and right (on canvas)
                if(x - 1 >= 0 && pixels[x-1][y].color == tempColor){
                    fillHelper(x-1, y);
                }
                if(x + 1 < widthNum && pixels[x+1][y].color == tempColor){
                    fillHelper(x+1, y);
                }

                //check up and down (on canvas)
                if(y - 1 >= 0 && pixels[x][y-1].color == tempColor){
                    fillHelper(x, y-1);
                }
                if(y + 1 < heightNum && pixels[x][y+1].color == tempColor){
                    fillHelper(x, y+1);
                }

            }

            function render(){
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.setTransform(viewportTransform.scale, 0, 0, viewportTransform.scale, viewportTransform.x, viewportTransform.y);

                //background
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, 750, 750, "black");
                
                //render grid
                for(var i = 0; i < widthNum; i++){
                    for(var j = 0; j < heightNum; j++){
                        drawPixel(pixels[i][j]);
                    }
                }
            }

            //buttons
            function fit(){
                viewportTransform.x = 0;
                viewportTransform.y = 0;
                viewportTransform.scale = 1;
                render();
            }

            function clearCanvas(){
                for(let i = 0; i < widthNum; i++){
                    for(let j = 0; j < heightNum; j++){
                        pixels[i][j].color = backgroundColor;
                        pixels[i][j].empty = true;
                    }
                }
                render();
            }
            function go(){
                heightNum = document.getElementById("height").value;
                widthNum = document.getElementById("width").value;
                pixelSize = 750/Math.max(heightNum, widthNum);

                document.getElementById("menu").style.display = "none";
                document.getElementById("main").style.display = "block";

                for(let i = 0; i < widthNum; i++){
                    var row = []
                    for(let j = 0; j < heightNum; j++){
                        row.push(new Pixel(i*pixelSize, j*pixelSize, backgroundColor, true));
                    }
                    pixels.push(row);
                }

                render();
            }
            function download(){
                var tempX = viewportTransform.x;
                var tempY = viewportTransform.y
                var tempScale = viewportTransform.scale;

                fit();
                let canvasUrl = canvas.toDataURL();
                const createEl = document.createElement('a');
                createEl.href = canvasUrl;
                createEl.download = "picture";
                createEl.click();
                createEl.remove();

                viewportTransform.x = tempX;
                viewportTransform.y = tempY;
                viewportTransform.scale = tempScale;
                render();
            }
            function reset(){
                document.getElementById("menu").style.display = "block";
                document.getElementById("main").style.display = "none";
                fit();
                pixels = []
            }
        
        </script>

    </body>
</html>